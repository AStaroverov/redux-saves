{
  "version": 3,
  "sources": ["../src/index.ts", "../src/reducer.ts", "../src/helpers.ts", "../src/helpers.ts", "../src/helpers.ts", "../src/helpers.ts", "../src/definitions.ts", "../src/definitions.ts", "../src/reducerWrapper.ts", "../src/middleware.ts"],
  "sourcesContent": ["import { savesReducer, TSavesState } from \"./reducer\";\nimport { savesReducerWrapper } from \"./reducerWrapper\";\nimport { createSavesMiddleware } from \"./middleware\";\nimport {\n  ActionType as SavesActionType,\n  createAddSaveAction,\n  createLoadSaveAction,\n  createClearSavesAction,\n  createLoadPrevSaveAction,\n  createLoadNextSaveAction,\n  createRemoveSavesAction,\n} from \"./definitions\";\n\nexport {\n  TSavesState,\n  SavesActionType,\n  createSavesMiddleware,\n  savesReducerWrapper,\n  savesReducer,\n  createClearSavesAction,\n  createAddSaveAction,\n  createRemoveSavesAction,\n  createLoadSaveAction,\n  createLoadPrevSaveAction,\n  createLoadNextSaveAction,\n}\n", "import { Action } from 'redux';\nimport { TGroupKey, TGroupSaveKey } from './definitions';\n\nexport const setSavesMetadataActionType: '@@REDUX_SAVES@@/setSavesMetadataActionType'\n  = '@@REDUX_SAVES@@/setSavesMetadataActionType';\n\nexport type TSavesState = {\n  groupSaves: Record<TGroupKey, TGroupSaveKey[] | void>;\n  currentBranchSaves: Record<TGroupKey, TGroupSaveKey[] | void>;\n  currentGroupSaves: Record<TGroupKey, TGroupSaveKey | void>;\n};\n\nexport function getInitialState(): TSavesState {\n  return {\n    groupSaves: {},\n    currentBranchSaves: {},\n    currentGroupSaves: {},\n  };\n}\n\nexport type TSetSavesMetadataAction = Action<typeof setSavesMetadataActionType> & { payload: TSavesState };\nexport function createSetSaveMetadataAction(payload: TSavesState): TSetSavesMetadataAction {\n  return {\n    type: setSavesMetadataActionType,\n    payload\n  };\n}\n\nexport function savesReducer(\n  state: TSavesState = getInitialState(),\n  action: Action | TSetSavesMetadataAction\n): TSavesState {\n  switch (action.type) {\n    case setSavesMetadataActionType: {\n      const { groupSaves, currentBranchSaves, currentGroupSaves } =\n        (action as TSetSavesMetadataAction).payload;\n\n\n      return {\n        ...state,\n        groupSaves: {\n          ...state.groupSaves,\n          ...groupSaves\n        },\n        currentBranchSaves: {\n          ...state.currentBranchSaves,\n          ...currentBranchSaves\n        },\n        currentGroupSaves: {\n          ...state.currentGroupSaves,\n          ...currentGroupSaves\n        },\n      }\n    }\n\n    default: return state\n  }\n}\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { Action } from \"redux\";\nimport { createGroupSaveKey } from \"./helpers\";\n\nexport const EMPTY_OBJECT = Object.freeze({});\n\nexport type TGroupKey = string | number;\nexport type TGroupSaveKey = string | number;\nexport type TSnapshot = unknown;\n\nexport type TGroupSave = {\n  key: TGroupSaveKey\n  groupKey: TGroupKey\n  prevSaveKey: TGroupSaveKey | void\n  nextSaveKey: TGroupSaveKey | void\n}\n\nexport type TSave = {\n  groupSaveKey: TGroupSaveKey\n  snapshot: TSnapshot\n}\n\nexport const DEFAULT_GROUP_KEY: TGroupKey = '__DEFAULT_GROUP_KEY__' as TGroupKey;\n\nexport type TBaseSaveAction<T = ActionType, P = void> = Action<T> & {\n  payload: P;\n}\n\nexport type TSaveActions =\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TClearSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n  | TLoadPrevSaveDoneAction\n  | TLoadNextSaveDoneAction\n\nexport type TValuableSaveActions =\n  | TClearSavesAction\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n\nexport const enum ActionType {\n  SetInitState = '@@REDUX_SAVE@@/SetInitState',\n  ClearSaves = '@@REDUX_SAVE@@/ClearSaves',\n  AddSave = '@@REDUX_SAVE@@/AddSave',\n  RemoveSaves = '@@REDUX_SAVE@@/RemoveLastsSaves',\n  LoadSave = '@@REDUX_SAVE@@/LoadSave',\n  LoadPrevSave = '@@REDUX_SAVE@@/LoadPrevSave',\n  LoadNextSave = '@@REDUX_SAVE@@/LoadNextSave',\n  LoadPrevSaveDone = '@@REDUX_SAVE@@/LoadPrevSaveDone',\n  LoadNextSaveDone = '@@REDUX_SAVE@@/LoadNextSaveDone',\n}\n\nexport const isValuableAction = (actionType: ActionType) => {\n  switch (actionType) {\n    case ActionType.ClearSaves:\n    case ActionType.AddSave:\n    case ActionType.LoadSave:\n    case ActionType.RemoveSaves:\n    case ActionType.LoadPrevSave:\n    case ActionType.LoadNextSave: {\n      return true;\n    }\n    default:\n      return false;\n  }\n};\n\nexport type TSetInitStateAction = Action<ActionType.SetInitState>;\nexport function createSetInitStateAction(): TSetInitStateAction {\n  return {\n    type: ActionType.SetInitState,\n  }\n}\n\nexport type TAddSaveAction = TBaseSaveAction<ActionType.AddSave, {\n  saveKey: TGroupSaveKey\n  groupKeys?: TGroupKey[],\n}>;\nexport function createAddSaveAction(\n  payload?: {\n    groupKeys?: TGroupKey[]\n    saveKey?: TGroupSaveKey,\n  }\n): TAddSaveAction {\n  return {\n    type: ActionType.AddSave,\n    payload: {\n      groupKeys: payload?.groupKeys as TGroupKey[],\n      saveKey: (payload?.saveKey || createGroupSaveKey()) as TGroupSaveKey,\n    },\n  }\n}\n\nexport type TRemoveSavesAction = TBaseSaveAction<ActionType.RemoveSaves, {\n  groupKeys?: TGroupKey[],\n  saveKeys?: TGroupSaveKey[],\n  exceptSaveKeys?: TGroupSaveKey[],\n}>;\nexport function createRemoveSavesAction(\n  payload?: {\n    groupKeys?: TGroupKey[],\n    saveKeys?: TGroupSaveKey[],\n    exceptSaveKeys?: TGroupSaveKey[],\n  }\n): TRemoveSavesAction {\n  return {\n    type: ActionType.RemoveSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TClearSavesAction = TBaseSaveAction<ActionType.ClearSaves, {\n  groupKeys?: TGroupKey[] | void\n}>;\nexport function createClearSavesAction(payload?: { groupKeys?: TGroupKey[] }): TClearSavesAction {\n  return {\n    type: ActionType.ClearSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TLoadSaveAction = TBaseSaveAction<ActionType.LoadSave, {\n  groupKeys?: TGroupKey[] | void,\n  saveKey: TGroupSaveKey\n}>;\nexport function createLoadSaveAction(payload: {\n  groupKeys?: TGroupKey[],\n  saveKey: TGroupSaveKey\n}): TLoadSaveAction {\n  return {\n    type: ActionType.LoadSave,\n    payload: payload as TLoadSaveAction['payload']\n  }\n}\n\nexport type TLoadPrevSaveAction = TBaseSaveAction<ActionType.LoadPrevSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadPrevSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadPrevSaveAction {\n  return {\n    type: ActionType.LoadPrevSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\nexport type TLoadNextSaveAction = TBaseSaveAction<ActionType.LoadNextSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadNextSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadNextSaveAction {\n  return {\n    type: ActionType.LoadNextSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\n// Just for trigger business logic\nexport type TLoadPrevSaveDoneAction = TBaseSaveAction<ActionType.LoadPrevSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadPrevSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadPrevSaveDoneAction {\n  return {\n    type: ActionType.LoadPrevSaveDone,\n    payload\n  }\n}\n\nexport type TLoadNextSaveDoneAction = TBaseSaveAction<ActionType.LoadNextSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadNextSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadNextSaveDoneAction {\n  return {\n    type: ActionType.LoadNextSaveDone,\n    payload\n  }\n}\n", "import { Action } from \"redux\";\nimport { createGroupSaveKey } from \"./helpers\";\n\nexport const EMPTY_OBJECT = Object.freeze({});\n\nexport type TGroupKey = string | number;\nexport type TGroupSaveKey = string | number;\nexport type TSnapshot = unknown;\n\nexport type TGroupSave = {\n  key: TGroupSaveKey\n  groupKey: TGroupKey\n  prevSaveKey: TGroupSaveKey | void\n  nextSaveKey: TGroupSaveKey | void\n}\n\nexport type TSave = {\n  groupSaveKey: TGroupSaveKey\n  snapshot: TSnapshot\n}\n\nexport const DEFAULT_GROUP_KEY: TGroupKey = '__DEFAULT_GROUP_KEY__' as TGroupKey;\n\nexport type TBaseSaveAction<T = ActionType, P = void> = Action<T> & {\n  payload: P;\n}\n\nexport type TSaveActions =\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TClearSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n  | TLoadPrevSaveDoneAction\n  | TLoadNextSaveDoneAction\n\nexport type TValuableSaveActions =\n  | TClearSavesAction\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n\nexport const enum ActionType {\n  SetInitState = '@@REDUX_SAVE@@/SetInitState',\n  ClearSaves = '@@REDUX_SAVE@@/ClearSaves',\n  AddSave = '@@REDUX_SAVE@@/AddSave',\n  RemoveSaves = '@@REDUX_SAVE@@/RemoveLastsSaves',\n  LoadSave = '@@REDUX_SAVE@@/LoadSave',\n  LoadPrevSave = '@@REDUX_SAVE@@/LoadPrevSave',\n  LoadNextSave = '@@REDUX_SAVE@@/LoadNextSave',\n  LoadPrevSaveDone = '@@REDUX_SAVE@@/LoadPrevSaveDone',\n  LoadNextSaveDone = '@@REDUX_SAVE@@/LoadNextSaveDone',\n}\n\nexport const isValuableAction = (actionType: ActionType) => {\n  switch (actionType) {\n    case ActionType.ClearSaves:\n    case ActionType.AddSave:\n    case ActionType.LoadSave:\n    case ActionType.RemoveSaves:\n    case ActionType.LoadPrevSave:\n    case ActionType.LoadNextSave: {\n      return true;\n    }\n    default:\n      return false;\n  }\n};\n\nexport type TSetInitStateAction = Action<ActionType.SetInitState>;\nexport function createSetInitStateAction(): TSetInitStateAction {\n  return {\n    type: ActionType.SetInitState,\n  }\n}\n\nexport type TAddSaveAction = TBaseSaveAction<ActionType.AddSave, {\n  saveKey: TGroupSaveKey\n  groupKeys?: TGroupKey[],\n}>;\nexport function createAddSaveAction(\n  payload?: {\n    groupKeys?: TGroupKey[]\n    saveKey?: TGroupSaveKey,\n  }\n): TAddSaveAction {\n  return {\n    type: ActionType.AddSave,\n    payload: {\n      groupKeys: payload?.groupKeys as TGroupKey[],\n      saveKey: (payload?.saveKey || createGroupSaveKey()) as TGroupSaveKey,\n    },\n  }\n}\n\nexport type TRemoveSavesAction = TBaseSaveAction<ActionType.RemoveSaves, {\n  groupKeys?: TGroupKey[],\n  saveKeys?: TGroupSaveKey[],\n  exceptSaveKeys?: TGroupSaveKey[],\n}>;\nexport function createRemoveSavesAction(\n  payload?: {\n    groupKeys?: TGroupKey[],\n    saveKeys?: TGroupSaveKey[],\n    exceptSaveKeys?: TGroupSaveKey[],\n  }\n): TRemoveSavesAction {\n  return {\n    type: ActionType.RemoveSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TClearSavesAction = TBaseSaveAction<ActionType.ClearSaves, {\n  groupKeys?: TGroupKey[] | void\n}>;\nexport function createClearSavesAction(payload?: { groupKeys?: TGroupKey[] }): TClearSavesAction {\n  return {\n    type: ActionType.ClearSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TLoadSaveAction = TBaseSaveAction<ActionType.LoadSave, {\n  groupKeys?: TGroupKey[] | void,\n  saveKey: TGroupSaveKey\n}>;\nexport function createLoadSaveAction(payload: {\n  groupKeys?: TGroupKey[],\n  saveKey: TGroupSaveKey\n}): TLoadSaveAction {\n  return {\n    type: ActionType.LoadSave,\n    payload: payload as TLoadSaveAction['payload']\n  }\n}\n\nexport type TLoadPrevSaveAction = TBaseSaveAction<ActionType.LoadPrevSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadPrevSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadPrevSaveAction {\n  return {\n    type: ActionType.LoadPrevSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\nexport type TLoadNextSaveAction = TBaseSaveAction<ActionType.LoadNextSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadNextSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadNextSaveAction {\n  return {\n    type: ActionType.LoadNextSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\n// Just for trigger business logic\nexport type TLoadPrevSaveDoneAction = TBaseSaveAction<ActionType.LoadPrevSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadPrevSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadPrevSaveDoneAction {\n  return {\n    type: ActionType.LoadPrevSaveDone,\n    payload\n  }\n}\n\nexport type TLoadNextSaveDoneAction = TBaseSaveAction<ActionType.LoadNextSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadNextSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadNextSaveDoneAction {\n  return {\n    type: ActionType.LoadNextSaveDone,\n    payload\n  }\n}\n", "import { Reducer, AnyAction } from \"redux\";\nimport {\n  ActionType,\n  TSaveActions,\n  TGroupKey,\n  DEFAULT_GROUP_KEY,\n  TSave,\n  TGroupSave,\n  isValuableAction,\n  TGroupSaveKey,\n  createSetInitStateAction,\n} from \"./definitions\";\nimport {\n  getCurrentGroupSaveKey,\n  createSaveStore,\n  getSaveStoreSize,\n  groupSavesIterator,\n  getSave,\n  createSave,\n  addSave,\n  clearSaves,\n  TSaveStore,\n  registerSaveStore,\n  setGroupChangeState,\n  getGroupChangeState,\n  deleteSave,\n  isGeneratedSaveKey,\n  getGroupSave,\n} from \"./helpers\";\n\n// savesReducerWrapper create for each reducer history and controls the content\nfunction savesReducerWrapper<S>(\n  groupKeyOrReducer: (string | symbol | number) | Reducer<S, AnyAction | TSaveActions>,\n  optionalReducer?: Reducer<S, AnyAction | TSaveActions>\n): Reducer<S, AnyAction | TSaveActions> {\n  const groupKey: TGroupKey = optionalReducer\n    ? (groupKeyOrReducer as TGroupKey)\n    : DEFAULT_GROUP_KEY;\n  const reducer: Reducer<S, AnyAction | TSaveActions> = optionalReducer\n    ? optionalReducer\n    : groupKeyOrReducer as Reducer<S, AnyAction | TSaveActions>;\n\n  const saveStore: TSaveStore = createSaveStore();\n  let currentSave: TSave | void;\n  const deleteSaveSafety = (groupSaveKey: TGroupSaveKey) => {\n    if (currentSave && currentSave.groupSaveKey === groupSaveKey) {\n      const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n      currentSave = groupSave.prevSaveKey !== undefined\n        ? getSave(saveStore, groupSave.prevSaveKey)\n        : undefined;\n    }\n\n    deleteSave(saveStore, groupSaveKey);\n  }\n\n  return (reducerState: S | undefined, action: AnyAction | TSaveActions): S => {\n    if (\n      // skip on init state\n      reducerState === undefined\n      // use init reducer for none redux-saves actions\n      || !isValuableAction(action.type)\n    ) {\n      const nextState = reducer(reducerState, action);\n\n      setGroupChangeState(\n        groupKey,\n        getGroupChangeState(groupKey)\n        || (currentSave === undefined ? true : currentSave.snapshot !== nextState)\n      );\n\n      return nextState;\n    }\n\n    // add history each history action, it give understanding that this reducer still alive\n    registerSaveStore(groupKey, saveStore);\n\n    // if action not for this group\n    if (\n      action.payload.groupKeys !== undefined\n      && action.payload.groupKeys.indexOf(groupKey) === -1\n    ) {\n      return reducer(reducerState, action);\n    }\n\n    const storeSize = getSaveStoreSize(saveStore);\n    const groupWasChanged = getGroupChangeState(groupKey) === true;\n    const currentGroupSaveKey = getCurrentGroupSaveKey(groupKey);\n\n    if (\n      (action.type === ActionType.LoadSave || action.type === ActionType.LoadPrevSave)\n      && currentGroupSaveKey\n    ) {\n      if (storeSize === 0) {\n        return reducerState;\n      }\n      \n      if (groupWasChanged) {\n        addSave(saveStore, createSave(currentGroupSaveKey, reducerState));\n      }\n\n      if (action.type === ActionType.LoadSave) {\n        currentSave = getSave(saveStore, action.payload.saveKey) || currentSave;\n\n        if (currentSave) {\n          return currentSave.snapshot as S;\n        }\n      }\n\n      if (action.type === ActionType.LoadPrevSave) {\n        let count = action.payload.count || 1;\n        \n        groupSavesIterator(\n          groupKey,\n          currentGroupSaveKey,\n          (groupSave) => {\n            currentSave = getSave(saveStore, groupSave.key) || currentSave;\n            return count-- === 0 ? undefined : groupSave.prevSaveKey;\n          }\n        ) as TGroupSave;\n\n        if (currentSave) {\n          return currentSave.snapshot as S;\n        }\n      }\n\n      return reducerState;\n    }\n\n    if (action.type === ActionType.LoadNextSave && currentGroupSaveKey) {\n      if (storeSize === 0) {\n        return reducerState;\n      }\n\n      let count = action.payload.count || 1;\n      \n      groupSavesIterator(\n        groupKey,\n        currentGroupSaveKey,\n        (groupSave) => {\n          currentSave = getSave(saveStore, groupSave.key) || currentSave;\n          return count-- === 0 ? undefined : groupSave.nextSaveKey;\n        }\n      ) as TGroupSave;\n\n      return currentSave ? currentSave.snapshot as S : reducerState;\n    }\n\n    if (action.type === ActionType.RemoveSaves && currentGroupSaveKey) {\n      if (storeSize === 0) {\n        return reducerState;\n      }\n\n      const { saveKeys, exceptSaveKeys } = action.payload;\n\n      if (saveKeys === undefined && exceptSaveKeys === undefined) {\n        deleteSaveSafety(currentGroupSaveKey);\n      }\n\n      if (saveKeys !== undefined) {\n        saveKeys.forEach(deleteSaveSafety);\n      } else if (exceptSaveKeys !== undefined) {\n        saveStore.forEach((_, saveKey) => {\n          if (exceptSaveKeys.indexOf(saveKey) !== -1) {\n            deleteSaveSafety(saveKey);\n          }\n        });\n      }\n\n      return reducerState;\n    }\n\n    if (\n      action.type === ActionType.AddSave\n      && (groupWasChanged || !isGeneratedSaveKey(action.payload.saveKey))\n    ) {\n      addSave(saveStore, currentSave = createSave(action.payload.saveKey, reducerState));\n    }\n\n    if (action.type === ActionType.ClearSaves) {\n      currentSave = undefined;\n      clearSaves(saveStore);\n    }\n\n    return reducerState;\n  };\n}\n\nexport { savesReducerWrapper }\n", "import { Middleware } from \"redux\";\nimport {\n  isValuableAction,\n  ActionType,\n  createLoadPrevSaveDoneAction,\n  createLoadNextSaveDoneAction,\n  TValuableSaveActions,\n  TGroupKey,\n  TGroupSave,\n  TGroupSaveKey,\n} from \"./definitions\";\nimport {\n  deleteSaveStores,\n  getGroupKeys,\n  clearGroupSaveStore,\n  addGroupSave,\n  createGroupSave,\n  getCurrentGroupSaveKey,\n  getGroupAutoSaveKey,\n  updateGroupAutoSaveKey,\n  groupSavesIterator,\n  setCurrentGroupSaveKey,\n  getGroupChangeState,\n  setGroupChangeState,\n  groupSaveStore,\n  deleteGroupSaveSafety,\n  isGeneratedSaveKey,\n  getGroupSave,\n  getGroupSaveKeys,\n  getBranchForSave,\n  trySetNextSaveKeyForGroupSave\n} from \"./helpers\";\nimport { createSetSaveMetadataAction } from \"./reducer\";\n\n// Middleware needs for control duplicate points in history and detect significant change,\nexport function createSavesMiddleware(): Middleware {\n  return function historyMiddleware(store) {\n    return (next) => (action: TValuableSaveActions) => {\n      // if action isn't valuable for history we can return default behavior\n      if (!isValuableAction(action.type)) {\n        return next(action);\n      }\n\n      const groupKeys: TGroupKey[] = action.payload.groupKeys || getGroupKeys();\n\n      if (groupKeys.length === 0) {\n        return next(action); \n      }\n\n      if (action.type === ActionType.AddSave) {\n        groupKeys.forEach((key) => {\n          const groupChangeState = getGroupChangeState(key);\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n          const currentGroupSave = currentGroupSaveKey\n            ? getGroupSave(key, currentGroupSaveKey)\n            : undefined;\n\n          if (groupChangeState) {\n            addGroupSave(\n              createGroupSave(\n                key,\n                action.payload.saveKey,\n                currentGroupSaveKey,\n              )\n            );\n\n            if (currentGroupSave !== undefined) {\n              trySetNextSaveKeyForGroupSave(key, currentGroupSave.key, action.payload.saveKey);\n            }\n\n            setCurrentGroupSaveKey(key, action.payload.saveKey);\n          } else\n            // for duplicate save this condition always will be true\n            if (currentGroupSave !== undefined) {\n            \n            // try create duplicate state\n            const isUserSaveKey = !isGeneratedSaveKey(action.payload.saveKey);\n            const prevSaveKey = currentGroupSave.prevSaveKey;\n\n            if (isUserSaveKey) {\n              addGroupSave(\n                createGroupSave(\n                  key,\n                  action.payload.saveKey,\n                  prevSaveKey,\n                )\n              );\n              \n              if (prevSaveKey !== undefined) {\n                trySetNextSaveKeyForGroupSave(key, prevSaveKey, action.payload.saveKey);\n              }\n\n              setCurrentGroupSaveKey(key, action.payload.saveKey);\n            }\n          }\n        });\n      }\n\n      if (\n        action.type === ActionType.LoadSave\n        || action.type === ActionType.LoadPrevSave\n      ) {\n        updateGroupAutoSaveKey();\n\n        groupKeys.forEach((key) => {\n          if (getGroupChangeState(key) === true) {\n            const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n            const saveKey = getGroupAutoSaveKey();\n            \n            addGroupSave(\n              createGroupSave(\n                key,\n                saveKey,\n                currentGroupSaveKey,\n              )\n            );\n\n            if (currentGroupSaveKey !== undefined) {\n              trySetNextSaveKeyForGroupSave(key, currentGroupSaveKey, saveKey);\n            }\n\n            setCurrentGroupSaveKey(key, saveKey);\n          }\n        });\n      }\n\n      // remove all histories for so as not to store dead reducers\n      // (if we unregister reducer dynamic modules)\n      getGroupKeys().forEach(deleteSaveStores)\n\n      const result = next(action);\n\n      if (action.type === ActionType.ClearSaves) {\n        groupKeys.forEach((key) => {\n          clearGroupSaveStore(key);\n          setCurrentGroupSaveKey(key, undefined);\n        });\n      }\n\n      const wasUpdatedGroupsKeys = new Set<TGroupKey>();\n\n      if (action.type === ActionType.AddSave) {\n        groupKeys.forEach((key) => {\n          setGroupChangeState(key, false);\n        });\n      }\n\n      if (action.type === ActionType.RemoveSaves) {\n        groupKeys.forEach((key) => {\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n\n          if (currentGroupSaveKey === undefined) {\n            return;\n          }\n\n          const { saveKeys, exceptSaveKeys } = action.payload;\n\n          if (saveKeys === undefined && exceptSaveKeys === undefined) {\n            deleteGroupSaveSafety(key, currentGroupSaveKey);\n          }\n\n          if (saveKeys !== undefined) {\n            saveKeys.forEach((saveKey) => {\n              deleteGroupSaveSafety(key, saveKey);\n            });\n          } else if (exceptSaveKeys !== undefined) {\n            groupSaveStore.get(key)!.forEach((groupSave) => {\n              if (exceptSaveKeys.indexOf(groupSave.key) !== -1) {\n                deleteGroupSaveSafety(key, groupSave.key);\n              }\n            });\n          }\n        });\n      }\n\n      if (action.type === ActionType.LoadSave) {\n        groupKeys.forEach((key) => {\n          setCurrentGroupSaveKey(key, action.payload.saveKey);\n          setGroupChangeState(key, false);\n        });\n      }\n\n      if (action.type === ActionType.LoadPrevSave) {\n        groupKeys.forEach((key) => {\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n\n          if (currentGroupSaveKey === undefined) {\n            return;\n          }\n\n          let steps = (action.payload.count || 1);\n          let nextGroupSaveKey: TGroupSaveKey;\n          const groupSave: TGroupSave = groupSavesIterator(\n            key,\n            currentGroupSaveKey,\n            (groupSave) => {\n              if (nextGroupSaveKey) {\n                groupSave.nextSaveKey = nextGroupSaveKey;\n              }\n\n              // while we load prev saves, we create chain for load next\n              nextGroupSaveKey = groupSave.key;\n\n              return steps-- === 0 ? undefined: groupSave.prevSaveKey;\n            }\n          ) as TGroupSave;\n\n          if (groupSave.key !== currentGroupSaveKey) {\n            wasUpdatedGroupsKeys.add(key);\n            setCurrentGroupSaveKey(key, groupSave.key);\n          }\n          setGroupChangeState(key, false);\n        });\n      }\n\n      if (action.type === ActionType.LoadNextSave) {\n        groupKeys.forEach(key => {\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n\n          if (currentGroupSaveKey === undefined) {\n            return;\n          }\n\n          let steps = action.payload.count || 1;\n          const groupSave: TGroupSave = groupSavesIterator(\n            key,\n            currentGroupSaveKey,\n            (groupSave) => {\n              return steps-- === 0 ? undefined :  groupSave.nextSaveKey;\n            }\n          ) as TGroupSave;\n\n          if (groupSave.key !== currentGroupSaveKey) {\n            wasUpdatedGroupsKeys.add(key);\n            setCurrentGroupSaveKey(key, groupSave.key);\n          }\n        });\n      }\n\n      const groupSaves: Record<TGroupKey, TGroupSaveKey[]> = {};\n      const currentBranchSaves: Record<TGroupKey, TGroupSaveKey[]> = {};\n      const currentGroupSaves: Record<TGroupKey, TGroupSaveKey | void> = {};\n\n      groupKeys.forEach((key) => {\n        groupSaves[key] = getGroupSaveKeys(key);\n        currentGroupSaves[key] = getCurrentGroupSaveKey(key);\n        currentBranchSaves[key] = currentGroupSaves[key]\n          ? getBranchForSave(key, currentGroupSaves[key] as TGroupSaveKey)\n          : [];\n      });\n\n      store.dispatch(\n        createSetSaveMetadataAction({ groupSaves, currentBranchSaves, currentGroupSaves })\n      );\n\n      if (wasUpdatedGroupsKeys.size > 0) {\n        if (action.type === ActionType.LoadPrevSave) {\n          store.dispatch(createLoadPrevSaveDoneAction({\n            groupKeys: Array.from(wasUpdatedGroupsKeys)\n          }));\n        }\n\n        if (action.type === ActionType.LoadNextSave) {\n          store.dispatch(createLoadNextSaveDoneAction({\n            groupKeys: Array.from(wasUpdatedGroupsKeys)\n          }));\n        }\n      }\n\n      return result;\n    };\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
