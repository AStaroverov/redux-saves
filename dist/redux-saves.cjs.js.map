{
  "version": 3,
  "sources": ["../src/index.ts", "../src/reducer.ts", "../src/helpers.ts", "../src/helpers.ts", "../src/helpers.ts", "../src/helpers.ts", "../src/definitions.ts", "../src/definitions.ts", "../src/reducerWrapper.ts", "../src/middleware.ts"],
  "sourcesContent": ["import { savesReducer, TSavesState } from \"./reducer\";\nimport { savesReducerWrapper } from \"./reducerWrapper\";\nimport { createSavesMiddleware } from \"./middleware\";\nimport {\n  ActionType as SavesActionType,\n  createAddSaveAction,\n  createLoadSaveAction,\n  createClearSavesAction,\n  createLoadPrevSaveAction,\n  createLoadNextSaveAction,\n  createRemoveSavesAction,\n} from \"./definitions\";\n\nexport {\n  TSavesState,\n  SavesActionType,\n  createSavesMiddleware,\n  savesReducerWrapper,\n  savesReducer,\n  createClearSavesAction,\n  createAddSaveAction,\n  createRemoveSavesAction,\n  createLoadSaveAction,\n  createLoadPrevSaveAction,\n  createLoadNextSaveAction,\n}\n", "import { Action } from 'redux';\nimport { TGroupKey, TGroupSaveKey } from './definitions';\n\nexport const setSavesMetadataActionType: '@@REDUX_SAVES@@/setSavesMetadataActionType'\n  = '@@REDUX_SAVES@@/setSavesMetadataActionType';\n\nexport type TSavesState = {\n  groupSaves: Record<TGroupKey, TGroupSaveKey[] | void>;\n  currentBranchSaves: Record<TGroupKey, TGroupSaveKey[] | void>;\n  currentGroupSaves: Record<TGroupKey, TGroupSaveKey | void>;\n};\n\nexport function getInitialState(): TSavesState {\n  return {\n    groupSaves: {},\n    currentBranchSaves: {},\n    currentGroupSaves: {},\n  };\n}\n\nexport type TSetSavesMetadataAction = Action<typeof setSavesMetadataActionType> & { payload: TSavesState };\nexport function createSetSaveMetadataAction(payload: TSavesState): TSetSavesMetadataAction {\n  return {\n    type: setSavesMetadataActionType,\n    payload\n  };\n}\n\nexport function savesReducer(\n  state: TSavesState = getInitialState(),\n  action: Action | TSetSavesMetadataAction\n): TSavesState {\n  switch (action.type) {\n    case setSavesMetadataActionType: {\n      const { groupSaves, currentBranchSaves, currentGroupSaves } =\n        (action as TSetSavesMetadataAction).payload;\n\n\n      return {\n        ...state,\n        groupSaves: {\n          ...state.groupSaves,\n          ...groupSaves\n        },\n        currentBranchSaves: {\n          ...state.currentBranchSaves,\n          ...currentBranchSaves\n        },\n        currentGroupSaves: {\n          ...state.currentGroupSaves,\n          ...currentGroupSaves\n        },\n      }\n    }\n\n    default: return state\n  }\n}\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { TGroupKey, TGroupSave, TGroupSaveKey, TSave, TSnapshot } from \"./definitions\";\n\n// saves prefix\nconst SAVE_PREFIX = '@@REDUX-SAVE@@';\n\nexport function isGeneratedSaveKey(key: TGroupSaveKey): boolean {\n  return typeof key === 'string' && key.startsWith(SAVE_PREFIX);\n}\n\n// create Group Save key\nlet groupSaveIndex = 0;\nexport function createGroupSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/save-${groupSaveIndex++}` as TGroupSaveKey;\n}\n\n// Autosave\nlet groupAutoSaveIndex = 0;\nexport function updateGroupAutoSaveKey(): void {\n  groupAutoSaveIndex += 1;\n}\n\nexport function getGroupAutoSaveKey(): TGroupSaveKey {\n  return `${SAVE_PREFIX}/autosave-${groupAutoSaveIndex}` as TGroupSaveKey;\n}\n\nexport const mapGroupKeyToNeedAutoSave = new Map<TGroupKey, boolean>();\nexport function setGroupChangeState(groupKey: TGroupKey, state: boolean): void {\n  mapGroupKeyToNeedAutoSave.set(groupKey, state);\n}\n\nexport function getGroupChangeState(groupKey: TGroupKey): boolean | void {\n  return mapGroupKeyToNeedAutoSave.get(groupKey);\n}\n\n// create Save\nexport function createSave(\n  groupSaveKey: TGroupSaveKey,\n  snapshot: TSnapshot,\n): TSave { \n  return { groupSaveKey, snapshot };\n}\n\nlet currentSaveIndex = 0;\n\nexport function getCurrentSaveIndex(): number {\n  return currentSaveIndex;\n}\n\nexport function increaseSaveIndex(): number {\n  return ++currentSaveIndex;\n}\n\n// GroupKeys\nlet isDirty: boolean = true;\nlet groupKeysArray: TGroupKey[];\nconst groupKeysSet = new Set<TGroupKey>();\n\nexport function addGroupKey(key: TGroupKey): void {\n  groupKeysSet.add(key);\n  isDirty = true;\n}\n\nexport function deleteGroupKey(key: TGroupKey): void {\n  groupKeysSet.delete(key);\n  isDirty = true;\n}\n\nexport function getGroupKeys(): TGroupKey[] {\n  if (isDirty) {\n    isDirty = false;\n    groupKeysArray = Array.from(groupKeysSet);\n  }\n\n  return groupKeysArray;\n}\n\n// Reducer Saves\nexport type TSaveStore = Map<TGroupSaveKey, TSave>;\n\nexport function createSaveStore(): TSaveStore {\n  return new Map();\n}\n\nexport function getSave(store: TSaveStore, key: TGroupSaveKey): TSave {\n  return store.get(key)!;\n}\n\nexport const getSaveStoreSize = (store: TSaveStore): number => store.size;\n\nexport function addSave(store: TSaveStore, save: TSave): void {\n  store.set(save.groupSaveKey, save);\n}\n\nexport function deleteSave(store: TSaveStore, key: TGroupSaveKey): void {\n  store.delete(key);\n}\n\nexport function clearSaves(store: TSaveStore): void {\n  store.clear();\n}\n\n// Group Saves\nexport function createGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  prevSaveKey?: TGroupSaveKey | void,\n  nextSaveKey?: TGroupSaveKey | void,\n): TGroupSave { \n  return { groupKey, key: saveKey, prevSaveKey, nextSaveKey };\n}\n\nexport function trySetNextSaveKeyForGroupSave(\n  groupKey: TGroupKey,\n  saveKey: TGroupSaveKey,\n  nextSaveKey: TGroupSaveKey\n): void {\n  const groupSave =\n    getGroupSave(groupKey, saveKey);\n\n  if (groupSave !== undefined) {\n    groupSave.nextSaveKey = nextSaveKey;\n  }\n}\n\n// Group Saves Store\nexport const groupSaveStore = new Map<TGroupKey, Map<TGroupSaveKey, TGroupSave>>()\n\nexport function getGroupSaveStoreSize (): number { return groupSaveStore.size; }\n\nexport function getGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSave {\n  return groupSaveStore.get(groupKey)!.get(saveKey)!;\n}\n\nexport function getGroupSaveKeys(groupKey: TGroupKey): TGroupSaveKey[] {\n  return Array.from(groupSaveStore.get(groupKey)?.keys() || []);\n}\n\nexport function getBranchForSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): TGroupSaveKey[] {\n  const branch: TGroupSaveKey[] = [];\n  const groupSave = getGroupSave(groupKey, saveKey);\n\n  if (groupSave === undefined) {\n    return branch;\n  }\n\n  branch.push(groupSave.key);\n\n  if (groupSave.nextSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.nextSaveKey,\n      (groupSave) => {\n        branch.push(groupSave.key);\n        return groupSave.nextSaveKey;\n      }\n    );\n  }\n  if (groupSave.prevSaveKey !== undefined) {\n    groupSavesIterator(\n      groupKey,\n      groupSave.prevSaveKey,\n      (groupSave) => {\n        branch.unshift(groupSave.key);\n        return groupSave.prevSaveKey;\n      }\n    );\n  }\n\n  return branch;\n}\n\nexport function addGroupSave(save: TGroupSave): void {\n  if (!groupSaveStore.has(save.groupKey)) {\n    groupSaveStore.set(save.groupKey, new Map());\n  }\n\n  groupSaveStore.get(save.groupKey)!.set(save.key, save);\n}\n\nexport function deleteGroupSave(groupKey: TGroupKey, saveKey: TGroupSaveKey): void {\n  groupSaveStore.get(groupKey)!.delete(saveKey);\n}\n\nexport function deleteGroupSaveSafety(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey\n): void {\n  const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n  if (groupSave.prevSaveKey && groupSave.nextSaveKey) {\n    const prevGroupSave = getGroupSave(groupKey, groupSave.prevSaveKey);\n    const nextGroupSave = getGroupSave(groupKey, groupSave.nextSaveKey);\n  \n    nextGroupSave.prevSaveKey = prevGroupSave.key;\n    prevGroupSave.nextSaveKey = nextGroupSave.key;\n  }\n\n  deleteGroupSave(groupKey, groupSave.key);\n\n  if (getCurrentGroupSaveKey(groupKey) === groupSaveKey) {\n    setCurrentGroupSaveKey(groupKey, groupSave.prevSaveKey);\n  }\n}\n\nexport function clearGroupSaveStore(key: TGroupKey): void {\n  groupSaveStore.get(key)?.clear();\n}\n\n// last group save\nconst mapGroupKeyToCurrentGroupSaveKey = new Map<TGroupKey, TGroupSaveKey | void>();\n\nexport function setCurrentGroupSaveKey(key: TGroupKey, saveKey: TGroupSaveKey | void): void {\n  mapGroupKeyToCurrentGroupSaveKey.set(key, saveKey);\n}\nexport function getCurrentGroupSaveKey(key: TGroupKey): TGroupSaveKey | void {\n  return mapGroupKeyToCurrentGroupSaveKey.get(key);\n}\n\n// groupSave iterator\nexport function groupSavesIterator(\n  groupKey: TGroupKey,\n  groupSaveKey: TGroupSaveKey,\n  cb: (groupSave: TGroupSave) => TGroupSaveKey | void,\n): TGroupSave | void {\n  let groupSave: TGroupSave | void = getGroupSave(groupKey, groupSaveKey);\n  let tmpGroupSave: TGroupSave | void;\n  \n  while (groupSave !== undefined) {\n    tmpGroupSave = groupSave;\n\n    const key = cb(groupSave);\n\n    groupSave = key ? getGroupSave(groupKey, key) : undefined;\n  }\n\n  return tmpGroupSave;\n}\n\n// Save stores\nexport const mapGroupKeyToSaveStores = new Map<TGroupKey, TSaveStore[]>();\n\nexport const getSaveStores = (groupKey: TGroupKey): TSaveStore[] => mapGroupKeyToSaveStores.get(groupKey)!;\n\nexport const deleteSaveStores = (groupKey: TGroupKey): void => {\n  deleteGroupKey(groupKey);\n  mapGroupKeyToSaveStores.delete(groupKey);\n};\n\nexport const registerSaveStore = (groupKey: TGroupKey, store: TSaveStore): void => {\n  if (!mapGroupKeyToSaveStores.has(groupKey)) {\n    addGroupKey(groupKey);\n    mapGroupKeyToSaveStores.set(groupKey, []);\n  }\n\n  mapGroupKeyToSaveStores.get(groupKey)!.push(store);\n};\n", "import { Action } from \"redux\";\nimport { createGroupSaveKey } from \"./helpers\";\n\nexport const EMPTY_OBJECT = Object.freeze({});\n\nexport type TGroupKey = string | number;\nexport type TGroupSaveKey = string | number;\nexport type TSnapshot = unknown;\n\nexport type TGroupSave = {\n  key: TGroupSaveKey\n  groupKey: TGroupKey\n  prevSaveKey: TGroupSaveKey | void\n  nextSaveKey: TGroupSaveKey | void\n}\n\nexport type TSave = {\n  groupSaveKey: TGroupSaveKey\n  snapshot: TSnapshot\n}\n\nexport const DEFAULT_GROUP_KEY: TGroupKey = '__DEFAULT_GROUP_KEY__' as TGroupKey;\n\nexport type TBaseSaveAction<T = ActionType, P = void> = Action<T> & {\n  payload: P;\n}\n\nexport type TSaveActions =\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TClearSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n  | TLoadPrevSaveDoneAction\n  | TLoadNextSaveDoneAction\n\nexport type TValuableSaveActions =\n  | TClearSavesAction\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n\nexport const enum ActionType {\n  SetInitState = '@@REDUX_SAVE@@/SetInitState',\n  ClearSaves = '@@REDUX_SAVE@@/ClearSaves',\n  AddSave = '@@REDUX_SAVE@@/AddSave',\n  RemoveSaves = '@@REDUX_SAVE@@/RemoveLastsSaves',\n  LoadSave = '@@REDUX_SAVE@@/LoadSave',\n  LoadPrevSave = '@@REDUX_SAVE@@/LoadPrevSave',\n  LoadNextSave = '@@REDUX_SAVE@@/LoadNextSave',\n  LoadPrevSaveDone = '@@REDUX_SAVE@@/LoadPrevSaveDone',\n  LoadNextSaveDone = '@@REDUX_SAVE@@/LoadNextSaveDone',\n}\n\nexport const isValuableAction = (actionType: ActionType) => {\n  switch (actionType) {\n    case ActionType.ClearSaves:\n    case ActionType.AddSave:\n    case ActionType.LoadSave:\n    case ActionType.RemoveSaves:\n    case ActionType.LoadPrevSave:\n    case ActionType.LoadNextSave: {\n      return true;\n    }\n    default:\n      return false;\n  }\n};\n\nexport type TSetInitStateAction = Action<ActionType.SetInitState>;\nexport function createSetInitStateAction(): TSetInitStateAction {\n  return {\n    type: ActionType.SetInitState,\n  }\n}\n\nexport type TAddSaveAction = TBaseSaveAction<ActionType.AddSave, {\n  saveKey: TGroupSaveKey\n  groupKeys?: TGroupKey[],\n}>;\nexport function createAddSaveAction(\n  payload?: {\n    groupKeys?: TGroupKey[]\n    saveKey?: TGroupSaveKey,\n  }\n): TAddSaveAction {\n  return {\n    type: ActionType.AddSave,\n    payload: {\n      groupKeys: payload?.groupKeys as TGroupKey[],\n      saveKey: (payload?.saveKey || createGroupSaveKey()) as TGroupSaveKey,\n    },\n  }\n}\n\nexport type TRemoveSavesAction = TBaseSaveAction<ActionType.RemoveSaves, {\n  groupKeys?: TGroupKey[],\n  saveKeys?: TGroupSaveKey[],\n  exceptSaveKeys?: TGroupSaveKey[],\n}>;\nexport function createRemoveSavesAction(\n  payload?: {\n    groupKeys?: TGroupKey[],\n    saveKeys?: TGroupSaveKey[],\n    exceptSaveKeys?: TGroupSaveKey[],\n  }\n): TRemoveSavesAction {\n  return {\n    type: ActionType.RemoveSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TClearSavesAction = TBaseSaveAction<ActionType.ClearSaves, {\n  groupKeys?: TGroupKey[] | void\n}>;\nexport function createClearSavesAction(payload?: { groupKeys?: TGroupKey[] }): TClearSavesAction {\n  return {\n    type: ActionType.ClearSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TLoadSaveAction = TBaseSaveAction<ActionType.LoadSave, {\n  groupKeys?: TGroupKey[] | void,\n  saveKey: TGroupSaveKey\n}>;\nexport function createLoadSaveAction(payload: {\n  groupKeys?: TGroupKey[],\n  saveKey: TGroupSaveKey\n}): TLoadSaveAction {\n  return {\n    type: ActionType.LoadSave,\n    payload: payload as TLoadSaveAction['payload']\n  }\n}\n\nexport type TLoadPrevSaveAction = TBaseSaveAction<ActionType.LoadPrevSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadPrevSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadPrevSaveAction {\n  return {\n    type: ActionType.LoadPrevSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\nexport type TLoadNextSaveAction = TBaseSaveAction<ActionType.LoadNextSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadNextSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadNextSaveAction {\n  return {\n    type: ActionType.LoadNextSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\n// Just for trigger business logic\nexport type TLoadPrevSaveDoneAction = TBaseSaveAction<ActionType.LoadPrevSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadPrevSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadPrevSaveDoneAction {\n  return {\n    type: ActionType.LoadPrevSaveDone,\n    payload\n  }\n}\n\nexport type TLoadNextSaveDoneAction = TBaseSaveAction<ActionType.LoadNextSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadNextSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadNextSaveDoneAction {\n  return {\n    type: ActionType.LoadNextSaveDone,\n    payload\n  }\n}\n", "import { Action } from \"redux\";\nimport { createGroupSaveKey } from \"./helpers\";\n\nexport const EMPTY_OBJECT = Object.freeze({});\n\nexport type TGroupKey = string | number;\nexport type TGroupSaveKey = string | number;\nexport type TSnapshot = unknown;\n\nexport type TGroupSave = {\n  key: TGroupSaveKey\n  groupKey: TGroupKey\n  prevSaveKey: TGroupSaveKey | void\n  nextSaveKey: TGroupSaveKey | void\n}\n\nexport type TSave = {\n  groupSaveKey: TGroupSaveKey\n  snapshot: TSnapshot\n}\n\nexport const DEFAULT_GROUP_KEY: TGroupKey = '__DEFAULT_GROUP_KEY__' as TGroupKey;\n\nexport type TBaseSaveAction<T = ActionType, P = void> = Action<T> & {\n  payload: P;\n}\n\nexport type TSaveActions =\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TClearSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n  | TLoadPrevSaveDoneAction\n  | TLoadNextSaveDoneAction\n\nexport type TValuableSaveActions =\n  | TClearSavesAction\n  | TAddSaveAction\n  | TRemoveSavesAction\n  | TLoadSaveAction\n  | TLoadPrevSaveAction\n  | TLoadNextSaveAction\n\nexport const enum ActionType {\n  SetInitState = '@@REDUX_SAVE@@/SetInitState',\n  ClearSaves = '@@REDUX_SAVE@@/ClearSaves',\n  AddSave = '@@REDUX_SAVE@@/AddSave',\n  RemoveSaves = '@@REDUX_SAVE@@/RemoveLastsSaves',\n  LoadSave = '@@REDUX_SAVE@@/LoadSave',\n  LoadPrevSave = '@@REDUX_SAVE@@/LoadPrevSave',\n  LoadNextSave = '@@REDUX_SAVE@@/LoadNextSave',\n  LoadPrevSaveDone = '@@REDUX_SAVE@@/LoadPrevSaveDone',\n  LoadNextSaveDone = '@@REDUX_SAVE@@/LoadNextSaveDone',\n}\n\nexport const isValuableAction = (actionType: ActionType) => {\n  switch (actionType) {\n    case ActionType.ClearSaves:\n    case ActionType.AddSave:\n    case ActionType.LoadSave:\n    case ActionType.RemoveSaves:\n    case ActionType.LoadPrevSave:\n    case ActionType.LoadNextSave: {\n      return true;\n    }\n    default:\n      return false;\n  }\n};\n\nexport type TSetInitStateAction = Action<ActionType.SetInitState>;\nexport function createSetInitStateAction(): TSetInitStateAction {\n  return {\n    type: ActionType.SetInitState,\n  }\n}\n\nexport type TAddSaveAction = TBaseSaveAction<ActionType.AddSave, {\n  saveKey: TGroupSaveKey\n  groupKeys?: TGroupKey[],\n}>;\nexport function createAddSaveAction(\n  payload?: {\n    groupKeys?: TGroupKey[]\n    saveKey?: TGroupSaveKey,\n  }\n): TAddSaveAction {\n  return {\n    type: ActionType.AddSave,\n    payload: {\n      groupKeys: payload?.groupKeys as TGroupKey[],\n      saveKey: (payload?.saveKey || createGroupSaveKey()) as TGroupSaveKey,\n    },\n  }\n}\n\nexport type TRemoveSavesAction = TBaseSaveAction<ActionType.RemoveSaves, {\n  groupKeys?: TGroupKey[],\n  saveKeys?: TGroupSaveKey[],\n  exceptSaveKeys?: TGroupSaveKey[],\n}>;\nexport function createRemoveSavesAction(\n  payload?: {\n    groupKeys?: TGroupKey[],\n    saveKeys?: TGroupSaveKey[],\n    exceptSaveKeys?: TGroupSaveKey[],\n  }\n): TRemoveSavesAction {\n  return {\n    type: ActionType.RemoveSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TClearSavesAction = TBaseSaveAction<ActionType.ClearSaves, {\n  groupKeys?: TGroupKey[] | void\n}>;\nexport function createClearSavesAction(payload?: { groupKeys?: TGroupKey[] }): TClearSavesAction {\n  return {\n    type: ActionType.ClearSaves,\n    payload: payload || EMPTY_OBJECT,\n  }\n}\n\nexport type TLoadSaveAction = TBaseSaveAction<ActionType.LoadSave, {\n  groupKeys?: TGroupKey[] | void,\n  saveKey: TGroupSaveKey\n}>;\nexport function createLoadSaveAction(payload: {\n  groupKeys?: TGroupKey[],\n  saveKey: TGroupSaveKey\n}): TLoadSaveAction {\n  return {\n    type: ActionType.LoadSave,\n    payload: payload as TLoadSaveAction['payload']\n  }\n}\n\nexport type TLoadPrevSaveAction = TBaseSaveAction<ActionType.LoadPrevSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadPrevSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadPrevSaveAction {\n  return {\n    type: ActionType.LoadPrevSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\nexport type TLoadNextSaveAction = TBaseSaveAction<ActionType.LoadNextSave, { groupKeys?: TGroupKey[] | void, count?: number }>;\nexport function createLoadNextSaveAction(payload?: { groupKeys?: TGroupKey[], count?: number }): TLoadNextSaveAction {\n  return {\n    type: ActionType.LoadNextSave,\n    payload: payload || EMPTY_OBJECT\n  }\n}\n\n// Just for trigger business logic\nexport type TLoadPrevSaveDoneAction = TBaseSaveAction<ActionType.LoadPrevSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadPrevSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadPrevSaveDoneAction {\n  return {\n    type: ActionType.LoadPrevSaveDone,\n    payload\n  }\n}\n\nexport type TLoadNextSaveDoneAction = TBaseSaveAction<ActionType.LoadNextSaveDone, { groupKeys?: TGroupKey[] }>;\nexport function createLoadNextSaveDoneAction(payload: { groupKeys: TGroupKey[] }): TLoadNextSaveDoneAction {\n  return {\n    type: ActionType.LoadNextSaveDone,\n    payload\n  }\n}\n", "import { Reducer, AnyAction } from \"redux\";\nimport {\n  ActionType,\n  TSaveActions,\n  TGroupKey,\n  DEFAULT_GROUP_KEY,\n  TSave,\n  TGroupSave,\n  isValuableAction,\n  TGroupSaveKey,\n  createSetInitStateAction,\n} from \"./definitions\";\nimport {\n  getCurrentGroupSaveKey,\n  createSaveStore,\n  getSaveStoreSize,\n  groupSavesIterator,\n  getSave,\n  createSave,\n  addSave,\n  clearSaves,\n  TSaveStore,\n  registerSaveStore,\n  setGroupChangeState,\n  getGroupChangeState,\n  deleteSave,\n  isGeneratedSaveKey,\n  getGroupSave,\n} from \"./helpers\";\n\n// savesReducerWrapper create for each reducer history and controls the content\nfunction savesReducerWrapper<S>(\n  groupKeyOrReducer: (string | symbol | number) | Reducer<S, AnyAction | TSaveActions>,\n  optionalReducer?: Reducer<S, AnyAction | TSaveActions>\n): Reducer<S, AnyAction | TSaveActions> {\n  const groupKey: TGroupKey = optionalReducer\n    ? (groupKeyOrReducer as TGroupKey)\n    : DEFAULT_GROUP_KEY;\n  const reducer: Reducer<S, AnyAction | TSaveActions> = optionalReducer\n    ? optionalReducer\n    : groupKeyOrReducer as Reducer<S, AnyAction | TSaveActions>;\n\n  const saveStore: TSaveStore = createSaveStore();\n  let currentSave: TSave | void;\n  const deleteSaveSafety = (groupSaveKey: TGroupSaveKey) => {\n    if (currentSave && currentSave.groupSaveKey === groupSaveKey) {\n      const groupSave = getGroupSave(groupKey, groupSaveKey);\n\n      currentSave = groupSave.prevSaveKey !== undefined\n        ? getSave(saveStore, groupSave.prevSaveKey)\n        : undefined;\n    }\n\n    deleteSave(saveStore, groupSaveKey);\n  }\n\n  return (reducerState: S | undefined, action: AnyAction | TSaveActions): S => {\n    if (\n      // skip on init state\n      reducerState === undefined\n      // use init reducer for none redux-saves actions\n      || !isValuableAction(action.type)\n    ) {\n      const nextState = reducer(reducerState, action);\n\n      setGroupChangeState(\n        groupKey,\n        getGroupChangeState(groupKey)\n        || (currentSave === undefined ? true : currentSave.snapshot !== nextState)\n      );\n\n      return nextState;\n    }\n\n    // add history each history action, it give understanding that this reducer still alive\n    registerSaveStore(groupKey, saveStore);\n\n    // if action not for this group\n    if (\n      action.payload.groupKeys !== undefined\n      && action.payload.groupKeys.indexOf(groupKey) === -1\n    ) {\n      return reducer(reducerState, action);\n    }\n\n    const storeSize = getSaveStoreSize(saveStore);\n    const groupWasChanged = getGroupChangeState(groupKey) === true;\n    const currentGroupSaveKey = getCurrentGroupSaveKey(groupKey);\n\n    if (\n      (action.type === ActionType.LoadSave || action.type === ActionType.LoadPrevSave)\n      && currentGroupSaveKey\n    ) {\n      if (storeSize === 0) {\n        return reducerState;\n      }\n      \n      if (groupWasChanged) {\n        addSave(saveStore, createSave(currentGroupSaveKey, reducerState));\n      }\n\n      if (action.type === ActionType.LoadSave) {\n        currentSave = getSave(saveStore, action.payload.saveKey) || currentSave;\n\n        if (currentSave) {\n          return currentSave.snapshot as S;\n        }\n      }\n\n      if (action.type === ActionType.LoadPrevSave) {\n        let count = action.payload.count || 1;\n        \n        groupSavesIterator(\n          groupKey,\n          currentGroupSaveKey,\n          (groupSave) => {\n            currentSave = getSave(saveStore, groupSave.key) || currentSave;\n            return count-- === 0 ? undefined : groupSave.prevSaveKey;\n          }\n        ) as TGroupSave;\n\n        if (currentSave) {\n          return currentSave.snapshot as S;\n        }\n      }\n\n      return reducerState;\n    }\n\n    if (action.type === ActionType.LoadNextSave && currentGroupSaveKey) {\n      if (storeSize === 0) {\n        return reducerState;\n      }\n\n      let count = action.payload.count || 1;\n      \n      groupSavesIterator(\n        groupKey,\n        currentGroupSaveKey,\n        (groupSave) => {\n          currentSave = getSave(saveStore, groupSave.key) || currentSave;\n          return count-- === 0 ? undefined : groupSave.nextSaveKey;\n        }\n      ) as TGroupSave;\n\n      return currentSave ? currentSave.snapshot as S : reducerState;\n    }\n\n    if (action.type === ActionType.RemoveSaves && currentGroupSaveKey) {\n      if (storeSize === 0) {\n        return reducerState;\n      }\n\n      const { saveKeys, exceptSaveKeys } = action.payload;\n\n      if (saveKeys === undefined && exceptSaveKeys === undefined) {\n        deleteSaveSafety(currentGroupSaveKey);\n      }\n\n      if (saveKeys !== undefined) {\n        saveKeys.forEach(deleteSaveSafety);\n      } else if (exceptSaveKeys !== undefined) {\n        saveStore.forEach((_, saveKey) => {\n          if (exceptSaveKeys.indexOf(saveKey) !== -1) {\n            deleteSaveSafety(saveKey);\n          }\n        });\n      }\n\n      return reducerState;\n    }\n\n    if (\n      action.type === ActionType.AddSave\n      && (groupWasChanged || !isGeneratedSaveKey(action.payload.saveKey))\n    ) {\n      addSave(saveStore, currentSave = createSave(action.payload.saveKey, reducerState));\n    }\n\n    if (action.type === ActionType.ClearSaves) {\n      currentSave = undefined;\n      clearSaves(saveStore);\n    }\n\n    return reducerState;\n  };\n}\n\nexport { savesReducerWrapper }\n", "import { Middleware } from \"redux\";\nimport {\n  isValuableAction,\n  ActionType,\n  createLoadPrevSaveDoneAction,\n  createLoadNextSaveDoneAction,\n  TValuableSaveActions,\n  TGroupKey,\n  TGroupSave,\n  TGroupSaveKey,\n} from \"./definitions\";\nimport {\n  deleteSaveStores,\n  getGroupKeys,\n  clearGroupSaveStore,\n  addGroupSave,\n  createGroupSave,\n  getCurrentGroupSaveKey,\n  getGroupAutoSaveKey,\n  updateGroupAutoSaveKey,\n  groupSavesIterator,\n  setCurrentGroupSaveKey,\n  getGroupChangeState,\n  setGroupChangeState,\n  groupSaveStore,\n  deleteGroupSaveSafety,\n  isGeneratedSaveKey,\n  getGroupSave,\n  getGroupSaveKeys,\n  getBranchForSave,\n  trySetNextSaveKeyForGroupSave\n} from \"./helpers\";\nimport { createSetSaveMetadataAction } from \"./reducer\";\n\n// Middleware needs for control duplicate points in history and detect significant change,\nexport function createSavesMiddleware(): Middleware {\n  return function historyMiddleware(store) {\n    return (next) => (action: TValuableSaveActions) => {\n      // if action isn't valuable for history we can return default behavior\n      if (!isValuableAction(action.type)) {\n        return next(action);\n      }\n\n      const groupKeys: TGroupKey[] = action.payload.groupKeys || getGroupKeys();\n\n      if (groupKeys.length === 0) {\n        return next(action); \n      }\n\n      if (action.type === ActionType.AddSave) {\n        groupKeys.forEach((key) => {\n          const groupChangeState = getGroupChangeState(key);\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n          const currentGroupSave = currentGroupSaveKey\n            ? getGroupSave(key, currentGroupSaveKey)\n            : undefined;\n\n          if (groupChangeState) {\n            addGroupSave(\n              createGroupSave(\n                key,\n                action.payload.saveKey,\n                currentGroupSaveKey,\n              )\n            );\n\n            if (currentGroupSave !== undefined) {\n              trySetNextSaveKeyForGroupSave(key, currentGroupSave.key, action.payload.saveKey);\n            }\n\n            setCurrentGroupSaveKey(key, action.payload.saveKey);\n          } else\n            // for duplicate save this condition always will be true\n            if (currentGroupSave !== undefined) {\n            \n            // try create duplicate state\n            const isUserSaveKey = !isGeneratedSaveKey(action.payload.saveKey);\n            const prevSaveKey = currentGroupSave.prevSaveKey;\n\n            if (isUserSaveKey) {\n              addGroupSave(\n                createGroupSave(\n                  key,\n                  action.payload.saveKey,\n                  prevSaveKey,\n                )\n              );\n              \n              if (prevSaveKey !== undefined) {\n                trySetNextSaveKeyForGroupSave(key, prevSaveKey, action.payload.saveKey);\n              }\n\n              setCurrentGroupSaveKey(key, action.payload.saveKey);\n            }\n          }\n        });\n      }\n\n      if (\n        action.type === ActionType.LoadSave\n        || action.type === ActionType.LoadPrevSave\n      ) {\n        updateGroupAutoSaveKey();\n\n        groupKeys.forEach((key) => {\n          if (getGroupChangeState(key) === true) {\n            const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n            const saveKey = getGroupAutoSaveKey();\n            \n            addGroupSave(\n              createGroupSave(\n                key,\n                saveKey,\n                currentGroupSaveKey,\n              )\n            );\n\n            if (currentGroupSaveKey !== undefined) {\n              trySetNextSaveKeyForGroupSave(key, currentGroupSaveKey, saveKey);\n            }\n\n            setCurrentGroupSaveKey(key, saveKey);\n          }\n        });\n      }\n\n      // remove all histories for so as not to store dead reducers\n      // (if we unregister reducer dynamic modules)\n      getGroupKeys().forEach(deleteSaveStores)\n\n      const result = next(action);\n\n      if (action.type === ActionType.ClearSaves) {\n        groupKeys.forEach((key) => {\n          clearGroupSaveStore(key);\n          setCurrentGroupSaveKey(key, undefined);\n        });\n      }\n\n      const wasUpdatedGroupsKeys = new Set<TGroupKey>();\n\n      if (action.type === ActionType.AddSave) {\n        groupKeys.forEach((key) => {\n          setGroupChangeState(key, false);\n        });\n      }\n\n      if (action.type === ActionType.RemoveSaves) {\n        groupKeys.forEach((key) => {\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n\n          if (currentGroupSaveKey === undefined) {\n            return;\n          }\n\n          const { saveKeys, exceptSaveKeys } = action.payload;\n\n          if (saveKeys === undefined && exceptSaveKeys === undefined) {\n            deleteGroupSaveSafety(key, currentGroupSaveKey);\n          }\n\n          if (saveKeys !== undefined) {\n            saveKeys.forEach((saveKey) => {\n              deleteGroupSaveSafety(key, saveKey);\n            });\n          } else if (exceptSaveKeys !== undefined) {\n            groupSaveStore.get(key)!.forEach((groupSave) => {\n              if (exceptSaveKeys.indexOf(groupSave.key) !== -1) {\n                deleteGroupSaveSafety(key, groupSave.key);\n              }\n            });\n          }\n        });\n      }\n\n      if (action.type === ActionType.LoadSave) {\n        groupKeys.forEach((key) => {\n          setCurrentGroupSaveKey(key, action.payload.saveKey);\n          setGroupChangeState(key, false);\n        });\n      }\n\n      if (action.type === ActionType.LoadPrevSave) {\n        groupKeys.forEach((key) => {\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n\n          if (currentGroupSaveKey === undefined) {\n            return;\n          }\n\n          let steps = (action.payload.count || 1);\n          let nextGroupSaveKey: TGroupSaveKey;\n          const groupSave: TGroupSave = groupSavesIterator(\n            key,\n            currentGroupSaveKey,\n            (groupSave) => {\n              if (nextGroupSaveKey) {\n                groupSave.nextSaveKey = nextGroupSaveKey;\n              }\n\n              // while we load prev saves, we create chain for load next\n              nextGroupSaveKey = groupSave.key;\n\n              return steps-- === 0 ? undefined: groupSave.prevSaveKey;\n            }\n          ) as TGroupSave;\n\n          if (groupSave.key !== currentGroupSaveKey) {\n            wasUpdatedGroupsKeys.add(key);\n            setCurrentGroupSaveKey(key, groupSave.key);\n          }\n          setGroupChangeState(key, false);\n        });\n      }\n\n      if (action.type === ActionType.LoadNextSave) {\n        groupKeys.forEach(key => {\n          const currentGroupSaveKey = getCurrentGroupSaveKey(key);\n\n          if (currentGroupSaveKey === undefined) {\n            return;\n          }\n\n          let steps = action.payload.count || 1;\n          const groupSave: TGroupSave = groupSavesIterator(\n            key,\n            currentGroupSaveKey,\n            (groupSave) => {\n              return steps-- === 0 ? undefined :  groupSave.nextSaveKey;\n            }\n          ) as TGroupSave;\n\n          if (groupSave.key !== currentGroupSaveKey) {\n            wasUpdatedGroupsKeys.add(key);\n            setCurrentGroupSaveKey(key, groupSave.key);\n          }\n        });\n      }\n\n      const groupSaves: Record<TGroupKey, TGroupSaveKey[]> = {};\n      const currentBranchSaves: Record<TGroupKey, TGroupSaveKey[]> = {};\n      const currentGroupSaves: Record<TGroupKey, TGroupSaveKey | void> = {};\n\n      groupKeys.forEach((key) => {\n        groupSaves[key] = getGroupSaveKeys(key);\n        currentGroupSaves[key] = getCurrentGroupSaveKey(key);\n        currentBranchSaves[key] = currentGroupSaves[key]\n          ? getBranchForSave(key, currentGroupSaves[key] as TGroupSaveKey)\n          : [];\n      });\n\n      store.dispatch(\n        createSetSaveMetadataAction({ groupSaves, currentBranchSaves, currentGroupSaves })\n      );\n\n      if (wasUpdatedGroupsKeys.size > 0) {\n        if (action.type === ActionType.LoadPrevSave) {\n          store.dispatch(createLoadPrevSaveDoneAction({\n            groupKeys: Array.from(wasUpdatedGroupsKeys)\n          }));\n        }\n\n        if (action.type === ActionType.LoadNextSave) {\n          store.dispatch(createLoadNextSaveDoneAction({\n            groupKeys: Array.from(wasUpdatedGroupsKeys)\n          }));\n        }\n      }\n\n      return result;\n    };\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
